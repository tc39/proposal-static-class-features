<!doctype html>
<meta charset="utf8">
<pre class=metadata>
title: Static class features
stage: 2
contributors: Daniel Ehrenberg, Jeff Morrison, Kevin Smith, Kevin Gibbons
</pre>
<style>
</style>

<emu-intro id=sec-intro>
  <h1>Introduction</h1>
  <p>This document specifies parts of the class features proposals which were split off in the November 2017 TC39 meeting from <a href="https://github.com/tc39/proposal-class-fields">class fields</a> and <a href="https://github.com/tc39/proposal-private-methods">private methods</a> proposals, for further consideration and advancement. In that meeting, static public fields, static private fields and static private methods were split off from the earlier "Stage 3" proposal and demoted to "Stage 2".</p>
  <p>This proposal defines static public fields, static private fields, and static private methods. Compared to past proposals, the semantics of private static methods have changed to allow the receiver of a private static method to be a subclass. For further context and motivation, see <a href="https://github.com/tc39/proposal-static-class-features">the explainer document</a>.</p>
  <p>This specification is phrased as a diff against the combination of the private methods and class fields proposals.</p>
</emu-intro>

<emu-clause id=sec-syntax>
  <h1>Syntax</h1>

  <emu-grammar>
    ClassElement[Yield, Await] :
      MethodDefinition[?Yield, ?Await]
      `static` MethodDefinition[?Yield, ?Await]
      FieldDefinition[?Yield, ?Await] `;`
      <ins>`static` FieldDefinition[?Yield, ?Await] `;`</ins>
      `;`
  </emu-grammar>

  <emu-clause id="sec-static-semantics-early-errors">
    <h1>Static Semantics: Early Errors</h1>
    <emu-grammar><ins>ClassElement : `static` FieldDefinition `;`</ins></emu-grammar>
    <ul>
      <li>
        <ins>It is a Syntax Error if PropName of |FieldDefinition| is `"prototype"` or `"constructor"`.</ins>
      </li>
    </ul>

    <emu-grammar>
      <del>ClassElement : `static` MethodDefinition</del>
    </emu-grammar>
    <ul>
      <li><del>It is a Syntax Error if PrivateBoundNames of |MethodDefinition| is non-empty.</del></li>
    </ul>
  </emu-clause>

</emu-clause>

<emu-clause id=sec-algorithms>
  <h1>Algorithms</h1>

<emu-clause id="initialize-class-elements" aoid="InitializeClassElements">
  <h1>InitializeClassElements(_F_, _proto_)</h1>

  <emu-alg>
    1. Assert: Type(_F_) is Object and Type(_proto_) is Object.
    1. Assert: _F_ is an ECMAScript function object.
    1. Assert: _proto_ is ! Get(_C_, `"prototype"`).
    1. Let _elements_ be the value of _F_'s [[Elements]] internal slot.
    1. For each item _element_ in order from _elements_,
      1. Assert: If _element_.[[Placement]] is `"prototype"` <del>or `"static"`</del>, then _element_.[[Key]] is not a Private Name.
      1. If _element_.[[Kind]] is `"method"`,
        1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
        1. Perform ? DefineClassElement(_receiver_, _element_).
    1. For each item _element_ in order from _elements_,
      1. If _element_.[[Kind]] is `"field"` and _element_.[[Placement]] is `"static"` or `"prototype"`,
        1. Assert: _element_.[[Descriptor]] does not have a [[Value]], [[Get]] or [[Set]] slot.
        1. Let _receiver_ be _F_ if _element_.[[Placement]] is `"static"`, else let _receiver_ be _proto_.
        1. Perform ? DefineClassElement(_receiver_, _element_).
    1. Return.
  </emu-alg>
  <emu-note type=editor>Value properties are added before initializers so that all methods are visible from all initializers</emu-note>
</emu-clause>

<emu-clause id="copy-immutable-private-elements" aoid=CopyImmutablePrivateElements>
  <h1>CopyImmutablePrivateElements ( _F_, _constructorProto_ )</h1>

  <emu-alg>
    1. For _entry_ in _constructorProto_.[[PrivateFieldDescriptors]],
      1. Let _name_ be _entry_.[[PrivateName]].
      1. Let _descriptor_ be _entry_.[[PrivateFieldDescriptor]].
      1. If IsAccessorDescriptor(_descriptor_) or _descriptor_.[[Writable]] is *false*,
        1. Perform ! PrivateFieldDefine(_name_, _F_, _descriptor_).
  </emu-alg>

  <emu-note>In this specification, the only elements which will be copied by this algorithm are static private methods and accessors.</emu-note>
</emu-clause>

  <emu-clause id="static-semantics-is-static">
    <h1>Static Semantics: IsStatic</h1>

      <emu-grammar>ClassElement : `static` FieldDefinition</emu-grammar>
      <emu-alg>
        1. Return *true*.
      </emu-alg>
  </emu-clause>

  <emu-clause id="runtime-semantics-class-definition-evaluation">
    <h1>Runtime Semantics: ClassDefinitionEvaluation</h1>
    <p>With parameter _className_.</p>
    <emu-grammar>ClassTail : ClassHeritage? `{` ClassBody? `}`</emu-grammar>
    <emu-alg>
      1. Let _lex_ be the LexicalEnvironment of the running execution context.
      1. Let _classScope_ be NewDeclarativeEnvironment(_lex_).
      1. Let _classScopeEnvRec_ be _classScope_'s EnvironmentRecord.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.CreateImmutableBinding(_className_, *true*).
      1. Let _outerPrivateEnvironment_ be the PrivateNameEnvironment of the running execution context.
      1. Let _classPrivateEnvironment_ be NewDeclarativeEnvironment(_outerPrivateEnvironment_).
      1. Let _classPrivateEnvRec_ be _classPrivateEnvironment_'s EnvironmentRecord.
      1. If |ClassBody_opt| is present, then
        1. For each element _dn_ of the PrivateBoundNames of |ClassBody_opt|,
          1. Perform _classPrivateEnvRec_.CreateImmutableBinding(_dn_, *true*).
      1. If |ClassHeritage_opt| is not present, then
        1. Let _protoParent_ be the intrinsic object %ObjectPrototype%.
        1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
      1. Else,
        1. Set the running execution context's LexicalEnvironment to _classScope_.
        1. Let _superclass_ be the result of evaluating |ClassHeritage|.
        1. Set the running execution context's LexicalEnvironment to _lex_.
        1. ReturnIfAbrupt(_superclass_).
        1. If _superclass_ is *null*, then
          1. Let _protoParent_ be *null*.
          1. Let _constructorParent_ be the intrinsic object %FunctionPrototype%.
        1. Else if IsConstructor(_superclass_) is *false*, throw a *TypeError* exception.
        1. Else,
          1. Let _protoParent_ be ? Get(_superclass_, `"prototype"`).
          1. If Type(_protoParent_) is neither Object nor Null, throw a *TypeError* exception.
          1. Let _constructorParent_ be _superclass_.
      1. Let _proto_ be ObjectCreate(_protoParent_).
      1. If |ClassBody_opt| is not present, let _constructor_ be ~empty~.
      1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.
      1. If _constructor_ is ~empty~, then
        1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor(... args){ super (...args);}</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
        1. Else,
          1. Let _constructor_ be the result of parsing the source text
            <pre><code class="javascript">constructor( ){ }</code></pre>
            using the syntactic grammar with the goal symbol |MethodDefinition[~Yield]|.
      1. Set the running execution context's LexicalEnvironment to _classScope_.
      1. Set the running execution context's PrivateNameEnvironment to _classPrivateEnvironment_.
      1. Let _constructorInfo_ be the result of performing DefineMethod for _constructor_ with arguments _proto_ and _constructorParent_ as the optional _functionPrototype_ argument.
      1. Assert: _constructorInfo_ is not an abrupt completion.
      1. Let _F_ be _constructorInfo_.[[Closure]].
      1. If |ClassHeritage_opt| is present and _protoParent_ is not *null*, then set _F_.[[ConstructorKind]] to `"derived"`.
      1. Perform MakeConstructor(_F_, *false*, _proto_).
      1. Perform MakeClassConstructor(_F_).
      1. Perform CreateMethodProperty(_proto_, `"constructor"`, _F_).
      1. If |ClassBody_opt| is not present, let _elements_ be a new empty List.
      1. Else, let _definitions_ be NonConstructorElementDefinitions of |ClassBody|. NOTE: Simply renaming this internal algorithm will be enough; it includes fields.
      1. Let _elements_ be a new empty List.
      1. For each |ClassElement| _d_ in order from _definitions_,
        1. Let _newElements_ be the result of performing ClassElementEvaluation for _d_ with arguments _F_, *false*, and ~empty~.
        1. If _newElements_ is an abrupt completion, then
          1. Set the running execution context's LexicalEnvironment to _lex_.
          1. Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.
          1. Return Completion(_status_).
        1. Append _newElements_ to _elements_
      1. Let _elements_ be CoalescePrivateAccessors(_elements_).
      1. Set the running execution context's LexicalEnvironment to _lex_.
      1. Set the running execution context's PrivateNameEnvironment to _outerPrivateEnvironment_.
      1. If _className_ is not *undefined*, then
        1. Perform _classScopeEnvRec_.InitializeBinding(_className_, _F_).
      1. Set the value of _F_'s [[Elements]] internal slot to _elements_.
      1. <ins>Perform ! CopyImmutablePrivateElements(_F_, _constructorParent_).</ins>
      1. Perform ? InitializeClassElements(_F_, _proto_).
      1. Return _F_.
    </emu-alg>
  </emu-clause>


</emu-clause>
